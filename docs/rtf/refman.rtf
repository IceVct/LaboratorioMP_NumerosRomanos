{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 9;}
{\s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext51 List Continue 0;}
{\s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext52 List Continue 1;}
{\s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext53 List Continue 2;}
{\s53\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext54 List Continue 3;}
{\s54\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext55 List Continue 4;}
{\s55\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext56 List Continue 5;}
{\s56\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext57 List Continue 6;}
{\s57\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext58 List Continue 7;}
{\s58\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 8;}
{\s59\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 9;}
{\s60\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext61 DescContinue 0;}
{\s61\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext62 DescContinue 1;}
{\s62\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext63 DescContinue 2;}
{\s63\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext64 DescContinue 3;}
{\s64\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext65 DescContinue 4;}
{\s65\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext66 DescContinue 5;}
{\s66\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext67 DescContinue 6;}
{\s67\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext68 DescContinue 7;}
{\s68\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 8;}
{\s69\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 9;}
{\s70\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext81 LatexTOC 0;}
{\s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext82 LatexTOC 1;}
{\s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext83 LatexTOC 2;}
{\s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext84 LatexTOC 3;}
{\s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext85 LatexTOC 4;}
{\s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext86 LatexTOC 5;}
{\s76\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext87 LatexTOC 6;}
{\s77\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext88 LatexTOC 7;}
{\s78\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 8;}
{\s79\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 9;}
{\s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext81 \sautoupd List Bullet 0;}
{\s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid \sbasedon0 \snext82 \sautoupd List Bullet 1;}
{\s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid \sbasedon0 \snext83 \sautoupd List Bullet 2;}
{\s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid \sbasedon0 \snext84 \sautoupd List Bullet 3;}
{\s84\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls5\adjustright \fs20\cgrid \sbasedon0 \snext85 \sautoupd List Bullet 4;}
{\s85\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls6\adjustright \fs20\cgrid \sbasedon0 \snext86 \sautoupd List Bullet 5;}
{\s86\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls7\adjustright \fs20\cgrid \sbasedon0 \snext87 \sautoupd List Bullet 6;}
{\s87\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls8\adjustright \fs20\cgrid \sbasedon0 \snext88 \sautoupd List Bullet 7;}
{\s88\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls9\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 8;}
{\s89\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls10\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 9;}
{\s90\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext91 \sautoupd List Enum 0;}
{\s91\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext92 \sautoupd List Enum 1;}
{\s92\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext93 \sautoupd List Enum 2;}
{\s93\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext94 \sautoupd List Enum 3;}
{\s94\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext95 \sautoupd List Enum 4;}
{\s95\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s96\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s97\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext98 \sautoupd List Enum 7;}
{\s98\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 8;}
{\s99\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 9;}
}
{\info 
{\title {\comment TRABALHO 2 - MP - 1/2017 - Victor Araujo Vieira - 140032801  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1.0 \par
}}TRABALHO 2 - MP - 1/2017 - Victor Araujo Vieira - 140032801}
{\comment Gerado porDoxgyen. }
{\creatim \yr2017\mo4\dy21\hr0\min13\sec14}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt TRABALHO 2 - MP - 1/2017 - Victor Araujo Vieira - 140032801}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Vers\'E3o 1.0\par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt Sexta, 21 de Abril de 2017 }}\par
\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \'CDndice\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\'CDndice dos ficheiros\par \pard\plain 
{\tc \v \'CDndice dos ficheiros}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Lista de ficheiros\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Lista de todos os ficheiros com uma breve descri\'E7\'E3o:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b include/{\b num_romanos.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b num_romanos.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b teste_num_romanos.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b teste_num_romanos_main.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Documenta\'E7\'E3o do ficheiro{\tc \v Documenta\'E7\'E3o do ficheiro}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia ao ficheiro include/num_romanos.hpp\par \pard\plain 
{\tc\tcl2 \v include/num_romanos.hpp}
{\xe \v include/num_romanos.hpp}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <string.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ERRO}\~ -1\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ValorDecimalAlgRomano} (char romano)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funcao que vai converter o algarismo romano para seu equivalente em arabico, individualmente. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ValidaI_X_C} (int *vetorNumeroRom, int tamanhoVetor)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funcao que valida os numeros I, X e C, que so podem aparecer ate 3 vezes seguidas. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ValidaV_L_D} (int *vetorNumeroRom, int tamanhoVetor)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funcao que valida os numeros V, L e D, que so podem aparecer uma vez. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ValidaSubstracoesCombinadas} (int *vetorNumeroRom, int tamanhoVetor)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funcao que valida subtracoes combinadas, ou seja, casos em que um dado valor eh menor que o proximo. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b CriaVetorNumerosArabicos} (char const *numRomano, int *vetorNumeroRom)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funcao que vai criar um vetor com os valores numericos individuais dos numeros romanos validos. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ConverteNumeroRomano} (char const *numRomano)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funcao que vai converter, de fato, o numero romano passado para arabico. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das macros\par
\pard\plain 
{\xe \v ERRO\:num_romanos.hpp}
{\xe \v num_romanos.hpp\:ERRO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ERRO\~ -1}}
\par
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v ConverteNumeroRomano\:num_romanos.hpp}
{\xe \v num_romanos.hpp\:ConverteNumeroRomano}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ConverteNumeroRomano (char const *  {\i numRomano})}}
\par
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funcao que vai converter, de fato, o numero romano passado para arabico. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funcao que vai receber uma string com um numero romano e, se ele for um numero valido, vai converter e retornar o valor em arabico. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E2metros:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i *numRomano} \cell }{String que contem o numero romano que sera convertido. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Retorna:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid Caso nao tenha ocorrido nenhum erro, retornara o numero romano convertido para arabico. \par
-1 Caso o numero romano passado como parametro seja invalido.\par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   210                                                \{\par
  211     int i = 0, tamString = strlen(numRomano), valorFinal = 0;\par
  212     int num1 = 0, num2 = 0; // receberao os numeros individuais convertidos de romano para arabico\par
  213     int vetorNumeroRom[30];\par
  214 \par
  223     i = 0;\par
  224     if(CriaVetorNumerosArabicos(numRomano, vetorNumeroRom) == ERRO)\{\par
  225         return ERRO;\par
  226     \}\par
  227 \par
  228     // se tiver mais de um V, L ou D, ja retorna erro, porque o numero eh invalido\par
  229     // se tiver mais de 3 I, X OU C, ja retorna erro, poruqe o numero eh invalido\par
  230     // se tiver algum erro relacionado a subtracoes combinadas, retorna erro\par
  231     if(ValidaV_L_D(vetorNumeroRom, tamString) == ERRO || ValidaI_X_C(vetorNumeroRom, tamString) == ERRO\par
  232        || ValidaSubstracoesCombinadas(vetorNumeroRom, tamString) == ERRO)\{\par
  233         return ERRO;\par
  234     \}\par
  235         \par
  236     \par
  237     //a ideia eh percorrer a string, e:\par
  238     //1. Pega um numero, se o proximo eh maior, valor final recebe a subtracao do proximo e do atual\par
  239     //2. Se nao eh maior, valor final recebe o proprio valor\par
  240     while(i < tamString)\{\par
  241         if(i+1 < tamString)\{\par
  242             num2 = vetorNumeroRom[i + 1];\par
  243         \}\par
  244         num1 = vetorNumeroRom[i];\par
  245         if(num1 < num2 && i+1 < tamString)\{\par
  246             valorFinal += num2 - num1;\par
  247             i += 2;\par
  248         \}else\{\par
  249             valorFinal += num1;\par
  250             i++;\par
  251         \}\par
  252     \}\par
  253     if(valorFinal > 3000) return ERRO; // se o valor final for maior que 3000, retorna erro\par
  254 \par
  255     return valorFinal;\par
  256 \}}
}
{\xe \v CriaVetorNumerosArabicos\:num_romanos.hpp}
{\xe \v num_romanos.hpp\:CriaVetorNumerosArabicos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CriaVetorNumerosArabicos (char const *  {\i numRomano}, int *  {\i vetorNumeroRom})}}
\par
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funcao que vai criar um vetor com os valores numericos individuais dos numeros romanos validos. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funcao que vai criar um vetor com os valores individuais arabicos, convertidos a partir do numero romano, caso ele seja valido. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E2metros:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i *numRomano} \cell }{String que contem o numero romano que sera convertido. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i *vetorNumeroRom} \cell }{Vetor de inteiros que corresponde ao vetor que sera inserido os valores convertidos. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Retorna:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 0 Caso o vetor tenha sido criado com sucesso. \par
-1 Caso tenha ocorrido um erro ao criar o vetor.\par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   183                                                                         \{\par
  184     int i = 0, tamString = strlen(numRomano), numAuxiliar = 0;\par
  185 \par
  195     if(tamString > 30) return ERRO; // se o tamanho da string for maior que 30, retorna erro\par
  196 \par
  197     //loop que vai inserir os valores individuais convertidos no vetor\par
  198     for(i = 0; i < tamString; i++)\{\par
  199         numAuxiliar = ValorDecimalAlgRomano(numRomano[i]);\par
  200         if(numAuxiliar == -1)\{ \par
  201             return ERRO;\par
  202         \}\par
  203         vetorNumeroRom[i] = numAuxiliar;\par
  204     \}\par
  205 \par
  206     return 0; \par
  207 \}\par
}
}
{\xe \v ValidaI_X_C\:num_romanos.hpp}
{\xe \v num_romanos.hpp\:ValidaI_X_C}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ValidaI_X_C (int *  {\i vetorNumeroRom}, int  {\i tamanhoVetor})}}
\par
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funcao que valida os numeros I, X e C, que so podem aparecer ate 3 vezes seguidas. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Vai pegar um vetor com os numeros ja convertidos, e a partir do vetor, vai verificar se os numeros I, X e C sao repetidos mais de 3 vezes seguidas. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E2metros:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i *vetorNumeroRom} \cell }{Vetor de inteiros que contem os numeros individuais romanos ja convertidos. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i tamanhoVetor} \cell }{Inteiro que corresponde ao tamanho do vetor. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Retorna:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 0 Caso seja valido. \par
-1 Caso seja invalido.\par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    32                                                       \{\par
   33     int contaI = 0, contaX = 0, contaC = 0; // contadores para a quantidade de Is, Xs e Cs que tem no numero romano\par
   34     int invalidaI = 0, invalidaX = 0, invalidaC = 0; // sao as variaveis que vao invalidar I, X e C\par
   35     int i = 0, j = 0;\par
   36 \par
   47     for(i = 0; i < tamanhoVetor; i++)\{\par
   48         if(vetorNumeroRom[i] == 1)\{\par
   49             contaI = 1; // contador eh inicializado como 1\par
   50             if(i+1 < tamanhoVetor)\{\par
   51                 j = i + 1;\par
   52                 while(vetorNumeroRom[j] == 1 && j < tamanhoVetor)\{\par
   53                     contaI++;\par
   54                     j++;\par
   55                 \}\par
   56                 if(contaI > 3) invalidaI = 1;\par
   57             \}\par
   58         \}\par
   59 \par
   60         if(vetorNumeroRom[i] == 10)\{\par
   61             contaX = 1; // contador eh inicializado como 1\par
   62             if(i+1 < tamanhoVetor)\{\par
   63                 j = i + 1;\par
   64                 while(vetorNumeroRom[j] == 10 && j < tamanhoVetor)\{\par
   65                     contaX++;\par
   66                     j++;\par
   67                 \}\par
   68                 if(contaX > 3) invalidaX = 1;\par
   69             \}\par
   70         \}\par
   71 \par
   72         if(vetorNumeroRom[i] == 1)\{\par
   73             contaC = 1; // contador eh inicializado como 1\par
   74             if(i+1 < tamanhoVetor)\{\par
   75                 j = i + 1;\par
   76                 while(vetorNumeroRom[j] == 100 && j < tamanhoVetor)\{\par
   77                     contaC++;\par
   78                     j++;\par
   79                 \}\par
   80                 if(contaC > 3) invalidaC = 1;\par
   81             \}\par
   82         \}\par
   83     \}\par
   84 \par
   85     //se qualquer um dos numeros for invalidado, retorna erro\par
   86     if((invalidaI == 1) || (invalidaX == 1) || (invalidaC == 1))\{\par
   87         return ERRO;\par
   88     \}\par
   89 \par
   90     return 0;\par
   91 \}\par
}
}
{\xe \v ValidaSubstracoesCombinadas\:num_romanos.hpp}
{\xe \v num_romanos.hpp\:ValidaSubstracoesCombinadas}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ValidaSubstracoesCombinadas (int *  {\i vetorNumeroRom}, int  {\i tamanhoVetor})}}
\par
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funcao que valida subtracoes combinadas, ou seja, casos em que um dado valor eh menor que o proximo. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Vai pegar um vetor com os numeros ja convertidos, e a partir do vetor, vai validar os casos com subtracoes combinadas, ou seja, quando tem um numero e um maior subsequente, como IX ou IV e vai verificar os casos de erro, para entao, validar esse numero romano. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E2metros:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i *vetorNumeroRom} \cell }{Vetor de inteiros que contem os numeros individuais romanos ja convertidos. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i tamanhoVetor} \cell }{Inteiro que corresponde ao tamanho do vetor. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Retorna:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 0 Caso seja valido. \par
-1 Caso seja invalido.\par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   129                                                                       \{\par
  130     int num1 = 0, num2 = 0, subtraido = 0;\par
  131     int i = 0, contaNumConv = 0;\par
  132     int vetorAuxiliar[30]; // vai receber os valores ja convertidos\par
  133     float divisaoMenMaior = 0; // variavel que vai receber a divisao do menor numero pelo maior e comparar\par
  134 \par
  145     //loop que vai percorrer o vetor e fazer as validacoes\par
  146     contaNumConv = 0;\par
  147     while(i < tamanhoVetor)\{\par
  148         if(i + 1 < tamanhoVetor)\{\par
  149             num2 = vetorNumeroRom[i + 1];\par
  150         \}\par
  151         num1 = vetorNumeroRom[i];\par
  152         if(num1 >= subtraido && subtraido > 0)\{\par
  153             return ERRO; //se o proximo valor for maior ou igual ao ultimo valor subtraido, retorna erro\par
  154         \}\par
  155         if(num1 < num2 && i+1 < tamanhoVetor)\{\par
  156             subtraido = num1;\par
  157             vetorAuxiliar[contaNumConv] = num2 - num1;\par
  158             divisaoMenMaior = (float)num1/num2;\par
  159             if(divisaoMenMaior < 0.1)\{\par
  160                 return ERRO; // se a divisao entre o menor numero e o maior for menor que 1/10, significa que eh invalido\par
  161             \}\par
  162             if(subtraido != 1 && subtraido != 10 && subtraido != 100)\{\par
  163                 return ERRO; // se o valor que vai ser subtraido for 5, 50 ou 500, retorna erro\par
  164             \}\par
  165             i += 2; \par
  166         \}else\{\par
  167             vetorAuxiliar[contaNumConv] = num1;\par
  168             i++;\par
  169         \}\par
  170         contaNumConv++;\par
  171     \}\par
  172 \par
  173     for(i = 1; i < contaNumConv; i++)\{\par
  174         if(vetorAuxiliar[i] > vetorAuxiliar[0])\{\par
  175             return ERRO; //se qualquer um dos numeros convertidos depois do primeiro for maior que o primeiro, retorna erro!\par
  176         \}\par
  177     \}\par
  178 \par
  179     return 0;\par
  180 \}\par
}
}
{\xe \v ValidaV_L_D\:num_romanos.hpp}
{\xe \v num_romanos.hpp\:ValidaV_L_D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ValidaV_L_D (int *  {\i vetorNumeroRom}, int  {\i tamanhoVetor})}}
\par
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funcao que valida os numeros V, L e D, que so podem aparecer uma vez. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Vai pegar um vetor com os numeros ja convertidos, e a partir do vetor, vai verificar se os numeros V, L e D aparecem mais de uma vez no numero romano. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E2metros:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i *vetorNumeroRom} \cell }{Vetor de inteiros que contem os numeros individuais romanos ja convertidos. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i tamanhoVetor} \cell }{Inteiro que corresponde ao tamanho do vetor. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Retorna:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 0 Caso seja valido. \par
-1 Caso seja invalido.\par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    94                                                       \{\par
   95     int contaV = 0, contaL = 0, contaD = 0; //contadores para a quantidade de Vs, Ls e Ds que tem no numero romano\par
   96     int i = 0;\par
   97 \par
  107     //vai percorrer o vetor e realizar as contagens\par
  108     for(i = 0; i < tamanhoVetor; i++)\{\par
  109         if(vetorNumeroRom[i] == 5)\{\par
  110             contaV++;\par
  111         \}\par
  112         if(vetorNumeroRom[i] == 50)\{\par
  113             contaL++;\par
  114         \}\par
  115         if(vetorNumeroRom[i] == 500)\{\par
  116             contaD++;\par
  117         \}\par
  118     \}\par
  119 \par
  120     //se qualquer um dos contadores for maior que 1, quer dizer que houve um erro\par
  121     if((contaV > 1) || (contaL > 1) || (contaD > 1))\{\par
  122         return ERRO;\par
  123     \}\par
  124 \par
  125     return 0; \par
  126 \}\par
}
}
{\xe \v ValorDecimalAlgRomano\:num_romanos.hpp}
{\xe \v num_romanos.hpp\:ValorDecimalAlgRomano}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ValorDecimalAlgRomano (char  {\i romano})}}
\par
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funcao que vai converter o algarismo romano para seu equivalente em arabico, individualmente. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Vai pegar um caracter que corresponde a um algarismo romano e converte ele. I = 1; V = 5; X = 10; L = 50; C = 100; D = 500; M = 1000. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E2metros:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i romano} \cell }{Caracter que corresponde ao numero romano. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Retorna:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid Retorna o numero romano convertido.\par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     6                                       \{\par
    7     int valorRetorno = 0;\par
    8 \par
   16     //se nao estiver entre esses, retorna -1, oq indica erro\par
   17     switch(romano)\{\par
   18         case 'I': valorRetorno = 1; break;\par
   19         case 'V': valorRetorno = 5; break;\par
   20         case 'X': valorRetorno = 10; break;\par
   21         case 'L': valorRetorno = 50; break;\par
   22         case 'C': valorRetorno = 100; break;\par
   23         case 'D': valorRetorno = 500; break;\par
   24         case 'M': valorRetorno = 1000; break;\par
   25         default: valorRetorno = ERRO;\par
   26     \}\par
   27 \par
   28     return valorRetorno;\par
   29 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia ao ficheiro src/num_romanos.cpp\par \pard\plain 
{\tc\tcl2 \v src/num_romanos.cpp}
{\xe \v src/num_romanos.cpp}
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "num_romanos.hpp"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ValorDecimalAlgRomano} (char romano)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funcao que vai converter o algarismo romano para seu equivalente em arabico, individualmente. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ValidaI_X_C} (int *vetorNumeroRom, int tamanhoVetor)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funcao que valida os numeros I, X e C, que so podem aparecer ate 3 vezes seguidas. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ValidaV_L_D} (int *vetorNumeroRom, int tamanhoVetor)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funcao que valida os numeros V, L e D, que so podem aparecer uma vez. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ValidaSubstracoesCombinadas} (int *vetorNumeroRom, int tamanhoVetor)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funcao que valida subtracoes combinadas, ou seja, casos em que um dado valor eh menor que o proximo. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b CriaVetorNumerosArabicos} (char const *numRomano, int *vetorNumeroRom)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funcao que vai criar um vetor com os valores numericos individuais dos numeros romanos validos. }{
}\par
}}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ConverteNumeroRomano} (char const *numRomano)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funcao que vai converter, de fato, o numero romano passado para arabico. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v ConverteNumeroRomano\:num_romanos.cpp}
{\xe \v num_romanos.cpp\:ConverteNumeroRomano}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ConverteNumeroRomano (char const *  {\i numRomano})}}
\par
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funcao que vai converter, de fato, o numero romano passado para arabico. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funcao que vai receber uma string com um numero romano e, se ele for um numero valido, vai converter e retornar o valor em arabico. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E2metros:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i *numRomano} \cell }{String que contem o numero romano que sera convertido. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Retorna:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid Caso nao tenha ocorrido nenhum erro, retornara o numero romano convertido para arabico. \par
-1 Caso o numero romano passado como parametro seja invalido.\par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   210                                                \{\par
  211     int i = 0, tamString = strlen(numRomano), valorFinal = 0;\par
  212     int num1 = 0, num2 = 0; // receberao os numeros individuais convertidos de romano para arabico\par
  213     int vetorNumeroRom[30];\par
  214 \par
  223     i = 0;\par
  224     if(CriaVetorNumerosArabicos(numRomano, vetorNumeroRom) == ERRO)\{\par
  225         return ERRO;\par
  226     \}\par
  227 \par
  228     // se tiver mais de um V, L ou D, ja retorna erro, porque o numero eh invalido\par
  229     // se tiver mais de 3 I, X OU C, ja retorna erro, poruqe o numero eh invalido\par
  230     // se tiver algum erro relacionado a subtracoes combinadas, retorna erro\par
  231     if(ValidaV_L_D(vetorNumeroRom, tamString) == ERRO || ValidaI_X_C(vetorNumeroRom, tamString) == ERRO\par
  232        || ValidaSubstracoesCombinadas(vetorNumeroRom, tamString) == ERRO)\{\par
  233         return ERRO;\par
  234     \}\par
  235         \par
  236     \par
  237     //a ideia eh percorrer a string, e:\par
  238     //1. Pega um numero, se o proximo eh maior, valor final recebe a subtracao do proximo e do atual\par
  239     //2. Se nao eh maior, valor final recebe o proprio valor\par
  240     while(i < tamString)\{\par
  241         if(i+1 < tamString)\{\par
  242             num2 = vetorNumeroRom[i + 1];\par
  243         \}\par
  244         num1 = vetorNumeroRom[i];\par
  245         if(num1 < num2 && i+1 < tamString)\{\par
  246             valorFinal += num2 - num1;\par
  247             i += 2;\par
  248         \}else\{\par
  249             valorFinal += num1;\par
  250             i++;\par
  251         \}\par
  252     \}\par
  253     if(valorFinal > 3000) return ERRO; // se o valor final for maior que 3000, retorna erro\par
  254 \par
  255     return valorFinal;\par
  256 \}}
}
{\xe \v CriaVetorNumerosArabicos\:num_romanos.cpp}
{\xe \v num_romanos.cpp\:CriaVetorNumerosArabicos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CriaVetorNumerosArabicos (char const *  {\i numRomano}, int *  {\i vetorNumeroRom})}}
\par
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funcao que vai criar um vetor com os valores numericos individuais dos numeros romanos validos. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funcao que vai criar um vetor com os valores individuais arabicos, convertidos a partir do numero romano, caso ele seja valido. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E2metros:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i *numRomano} \cell }{String que contem o numero romano que sera convertido. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i *vetorNumeroRom} \cell }{Vetor de inteiros que corresponde ao vetor que sera inserido os valores convertidos. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Retorna:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 0 Caso o vetor tenha sido criado com sucesso. \par
-1 Caso tenha ocorrido um erro ao criar o vetor.\par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   183                                                                         \{\par
  184     int i = 0, tamString = strlen(numRomano), numAuxiliar = 0;\par
  185 \par
  195     if(tamString > 30) return ERRO; // se o tamanho da string for maior que 30, retorna erro\par
  196 \par
  197     //loop que vai inserir os valores individuais convertidos no vetor\par
  198     for(i = 0; i < tamString; i++)\{\par
  199         numAuxiliar = ValorDecimalAlgRomano(numRomano[i]);\par
  200         if(numAuxiliar == -1)\{ \par
  201             return ERRO;\par
  202         \}\par
  203         vetorNumeroRom[i] = numAuxiliar;\par
  204     \}\par
  205 \par
  206     return 0; \par
  207 \}\par
}
}
{\xe \v ValidaI_X_C\:num_romanos.cpp}
{\xe \v num_romanos.cpp\:ValidaI_X_C}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ValidaI_X_C (int *  {\i vetorNumeroRom}, int  {\i tamanhoVetor})}}
\par
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funcao que valida os numeros I, X e C, que so podem aparecer ate 3 vezes seguidas. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Vai pegar um vetor com os numeros ja convertidos, e a partir do vetor, vai verificar se os numeros I, X e C sao repetidos mais de 3 vezes seguidas. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E2metros:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i *vetorNumeroRom} \cell }{Vetor de inteiros que contem os numeros individuais romanos ja convertidos. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i tamanhoVetor} \cell }{Inteiro que corresponde ao tamanho do vetor. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Retorna:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 0 Caso seja valido. \par
-1 Caso seja invalido.\par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    32                                                       \{\par
   33     int contaI = 0, contaX = 0, contaC = 0; // contadores para a quantidade de Is, Xs e Cs que tem no numero romano\par
   34     int invalidaI = 0, invalidaX = 0, invalidaC = 0; // sao as variaveis que vao invalidar I, X e C\par
   35     int i = 0, j = 0;\par
   36 \par
   47     for(i = 0; i < tamanhoVetor; i++)\{\par
   48         if(vetorNumeroRom[i] == 1)\{\par
   49             contaI = 1; // contador eh inicializado como 1\par
   50             if(i+1 < tamanhoVetor)\{\par
   51                 j = i + 1;\par
   52                 while(vetorNumeroRom[j] == 1 && j < tamanhoVetor)\{\par
   53                     contaI++;\par
   54                     j++;\par
   55                 \}\par
   56                 if(contaI > 3) invalidaI = 1;\par
   57             \}\par
   58         \}\par
   59 \par
   60         if(vetorNumeroRom[i] == 10)\{\par
   61             contaX = 1; // contador eh inicializado como 1\par
   62             if(i+1 < tamanhoVetor)\{\par
   63                 j = i + 1;\par
   64                 while(vetorNumeroRom[j] == 10 && j < tamanhoVetor)\{\par
   65                     contaX++;\par
   66                     j++;\par
   67                 \}\par
   68                 if(contaX > 3) invalidaX = 1;\par
   69             \}\par
   70         \}\par
   71 \par
   72         if(vetorNumeroRom[i] == 1)\{\par
   73             contaC = 1; // contador eh inicializado como 1\par
   74             if(i+1 < tamanhoVetor)\{\par
   75                 j = i + 1;\par
   76                 while(vetorNumeroRom[j] == 100 && j < tamanhoVetor)\{\par
   77                     contaC++;\par
   78                     j++;\par
   79                 \}\par
   80                 if(contaC > 3) invalidaC = 1;\par
   81             \}\par
   82         \}\par
   83     \}\par
   84 \par
   85     //se qualquer um dos numeros for invalidado, retorna erro\par
   86     if((invalidaI == 1) || (invalidaX == 1) || (invalidaC == 1))\{\par
   87         return ERRO;\par
   88     \}\par
   89 \par
   90     return 0;\par
   91 \}\par
}
}
{\xe \v ValidaSubstracoesCombinadas\:num_romanos.cpp}
{\xe \v num_romanos.cpp\:ValidaSubstracoesCombinadas}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ValidaSubstracoesCombinadas (int *  {\i vetorNumeroRom}, int  {\i tamanhoVetor})}}
\par
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funcao que valida subtracoes combinadas, ou seja, casos em que um dado valor eh menor que o proximo. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Vai pegar um vetor com os numeros ja convertidos, e a partir do vetor, vai validar os casos com subtracoes combinadas, ou seja, quando tem um numero e um maior subsequente, como IX ou IV e vai verificar os casos de erro, para entao, validar esse numero romano. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E2metros:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i *vetorNumeroRom} \cell }{Vetor de inteiros que contem os numeros individuais romanos ja convertidos. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i tamanhoVetor} \cell }{Inteiro que corresponde ao tamanho do vetor. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Retorna:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 0 Caso seja valido. \par
-1 Caso seja invalido.\par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   129                                                                       \{\par
  130     int num1 = 0, num2 = 0, subtraido = 0;\par
  131     int i = 0, contaNumConv = 0;\par
  132     int vetorAuxiliar[30]; // vai receber os valores ja convertidos\par
  133     float divisaoMenMaior = 0; // variavel que vai receber a divisao do menor numero pelo maior e comparar\par
  134 \par
  145     //loop que vai percorrer o vetor e fazer as validacoes\par
  146     contaNumConv = 0;\par
  147     while(i < tamanhoVetor)\{\par
  148         if(i + 1 < tamanhoVetor)\{\par
  149             num2 = vetorNumeroRom[i + 1];\par
  150         \}\par
  151         num1 = vetorNumeroRom[i];\par
  152         if(num1 >= subtraido && subtraido > 0)\{\par
  153             return ERRO; //se o proximo valor for maior ou igual ao ultimo valor subtraido, retorna erro\par
  154         \}\par
  155         if(num1 < num2 && i+1 < tamanhoVetor)\{\par
  156             subtraido = num1;\par
  157             vetorAuxiliar[contaNumConv] = num2 - num1;\par
  158             divisaoMenMaior = (float)num1/num2;\par
  159             if(divisaoMenMaior < 0.1)\{\par
  160                 return ERRO; // se a divisao entre o menor numero e o maior for menor que 1/10, significa que eh invalido\par
  161             \}\par
  162             if(subtraido != 1 && subtraido != 10 && subtraido != 100)\{\par
  163                 return ERRO; // se o valor que vai ser subtraido for 5, 50 ou 500, retorna erro\par
  164             \}\par
  165             i += 2; \par
  166         \}else\{\par
  167             vetorAuxiliar[contaNumConv] = num1;\par
  168             i++;\par
  169         \}\par
  170         contaNumConv++;\par
  171     \}\par
  172 \par
  173     for(i = 1; i < contaNumConv; i++)\{\par
  174         if(vetorAuxiliar[i] > vetorAuxiliar[0])\{\par
  175             return ERRO; //se qualquer um dos numeros convertidos depois do primeiro for maior que o primeiro, retorna erro!\par
  176         \}\par
  177     \}\par
  178 \par
  179     return 0;\par
  180 \}\par
}
}
{\xe \v ValidaV_L_D\:num_romanos.cpp}
{\xe \v num_romanos.cpp\:ValidaV_L_D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ValidaV_L_D (int *  {\i vetorNumeroRom}, int  {\i tamanhoVetor})}}
\par
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funcao que valida os numeros V, L e D, que so podem aparecer uma vez. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Vai pegar um vetor com os numeros ja convertidos, e a partir do vetor, vai verificar se os numeros V, L e D aparecem mais de uma vez no numero romano. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E2metros:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i *vetorNumeroRom} \cell }{Vetor de inteiros que contem os numeros individuais romanos ja convertidos. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i tamanhoVetor} \cell }{Inteiro que corresponde ao tamanho do vetor. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Retorna:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid 0 Caso seja valido. \par
-1 Caso seja invalido.\par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid    94                                                       \{\par
   95     int contaV = 0, contaL = 0, contaD = 0; //contadores para a quantidade de Vs, Ls e Ds que tem no numero romano\par
   96     int i = 0;\par
   97 \par
  107     //vai percorrer o vetor e realizar as contagens\par
  108     for(i = 0; i < tamanhoVetor; i++)\{\par
  109         if(vetorNumeroRom[i] == 5)\{\par
  110             contaV++;\par
  111         \}\par
  112         if(vetorNumeroRom[i] == 50)\{\par
  113             contaL++;\par
  114         \}\par
  115         if(vetorNumeroRom[i] == 500)\{\par
  116             contaD++;\par
  117         \}\par
  118     \}\par
  119 \par
  120     //se qualquer um dos contadores for maior que 1, quer dizer que houve um erro\par
  121     if((contaV > 1) || (contaL > 1) || (contaD > 1))\{\par
  122         return ERRO;\par
  123     \}\par
  124 \par
  125     return 0; \par
  126 \}\par
}
}
{\xe \v ValorDecimalAlgRomano\:num_romanos.cpp}
{\xe \v num_romanos.cpp\:ValorDecimalAlgRomano}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ValorDecimalAlgRomano (char  {\i romano})}}
\par
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funcao que vai converter o algarismo romano para seu equivalente em arabico, individualmente. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Vai pegar um caracter que corresponde a um algarismo romano e converte ele. I = 1; V = 5; X = 10; L = 50; C = 100; D = 500; M = 1000. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E2metros:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i romano} \cell }{Caracter que corresponde ao numero romano. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Retorna:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid Retorna o numero romano convertido.\par
}}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     6                                       \{\par
    7     int valorRetorno = 0;\par
    8 \par
   16     //se nao estiver entre esses, retorna -1, oq indica erro\par
   17     switch(romano)\{\par
   18         case 'I': valorRetorno = 1; break;\par
   19         case 'V': valorRetorno = 5; break;\par
   20         case 'X': valorRetorno = 10; break;\par
   21         case 'L': valorRetorno = 50; break;\par
   22         case 'C': valorRetorno = 100; break;\par
   23         case 'D': valorRetorno = 500; break;\par
   24         case 'M': valorRetorno = 1000; break;\par
   25         default: valorRetorno = ERRO;\par
   26     \}\par
   27 \par
   28     return valorRetorno;\par
   29 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia ao ficheiro src/teste_num_romanos.cpp\par \pard\plain 
{\tc\tcl2 \v src/teste_num_romanos.cpp}
{\xe \v src/teste_num_romanos.cpp}
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "num_romanos.hpp"}\par
{\f2 #include "../include/catch.hpp"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Fun\'E7\'F5es\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TEST_CASE} ("Numeros romanos para arabicos","[romanos_arabicos]")\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Test case vai testar todas as funcoes implementadas no programa. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das fun\'E7\'F5es\par
\pard\plain 
{\xe \v TEST_CASE\:teste_num_romanos.cpp}
{\xe \v teste_num_romanos.cpp\:TEST_CASE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TEST_CASE ("Numeros romanos para arabicos" , "" [romanos_arabicos])}}
\par
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Test case vai testar todas as funcoes implementadas no programa. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TEST_CASE da framework de testes catch. Cada uma das secoes dessa teste case vai testar as funcoes implementadas no programa.\par
}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     5                                                                 \{\par
   11     //essa secao testa a funcao ValorDecimalAlgRomano\par
   12     SECTION("Testando a funcao que retorna o algarismo arabico correspondente")\{\par
   13         REQUIRE(ValorDecimalAlgRomano('I') == 1);\par
   14         REQUIRE(ValorDecimalAlgRomano('V') == 5);\par
   15         REQUIRE(ValorDecimalAlgRomano('X') == 10);\par
   16         REQUIRE(ValorDecimalAlgRomano('L') == 50);\par
   17         REQUIRE(ValorDecimalAlgRomano('C') == 100);\par
   18         REQUIRE(ValorDecimalAlgRomano('D') == 500);\par
   19         REQUIRE(ValorDecimalAlgRomano('M') == 1000);\par
   20         REQUIRE(ValorDecimalAlgRomano('s') == -1);\par
   21         REQUIRE(ValorDecimalAlgRomano('-') == -1);\par
   22         REQUIRE(ValorDecimalAlgRomano('i') == -1);\par
   23     \}\par
   24 \par
   25     //essa secao testa a funcao CriaVetorNumerosArabicos\par
   26     int vetor[30];\par
   27     SECTION("Testando a funcao que cria um vetor com os numeros ja convertidos para arabico")\{\par
   28         REQUIRE(CriaVetorNumerosArabicos("XXX", vetor) == 0);\par
   29         REQUIRE(CriaVetorNumerosArabicos("IV", vetor) == 0);\par
   30         REQUIRE(CriaVetorNumerosArabicos("zs", vetor) == ERRO);\par
   31         REQUIRE(CriaVetorNumerosArabicos("02", vetor) == ERRO);\par
   32         REQUIRE(CriaVetorNumerosArabicos("MMMI", vetor) == 0);\par
   33         REQUIRE(CriaVetorNumerosArabicos("MCDEA", vetor) == ERRO);\par
   34     \}\par
   35 \par
   36     //essa secao testa a funcao ValidaV_L_D\par
   37     SECTION("Testando a funcao que valida a quantidade de V, L e D que existem no numero romano")\{\par
   38         int vetor[] = \{10, 5, 1\};\par
   39         REQUIRE(ValidaV_L_D(vetor, 3) == 0);\par
   40         int vetor1[] = \{10, 5, 5\};\par
   41         REQUIRE(ValidaV_L_D(vetor1, 3) == ERRO);\par
   42         int vetor2[] = \{10, 5, 1, 5\};\par
   43         REQUIRE(ValidaV_L_D(vetor2, 4) == ERRO);\par
   44         int vetor3[] = \{5, 50, 50, 5\};\par
   45         REQUIRE(ValidaV_L_D(vetor3, 4) == ERRO);\par
   46         int vetor4[] = \{100, 50, 1\};\par
   47         REQUIRE(ValidaV_L_D(vetor4, 3) == 0);\par
   48         int vetor5[] = \{100, 500, 500\};\par
   49         REQUIRE(ValidaV_L_D(vetor5, 3) == ERRO);\par
   50         int vetor6[] = \{100, 1000, 5, 1, 1, 1\};\par
   51         REQUIRE(ValidaV_L_D(vetor6, 6) == 0);\par
   52     \}\par
   53 \par
   54     //essa secao testa a funcao ValidaI_X_C\par
   55     SECTION("Testando a funcao que valida a quantidade de I, X e C que existem no numero romano")\{\par
   56         int vetor[] = \{10, 10, 10\};\par
   57         REQUIRE(ValidaI_X_C(vetor, 3) == 0);\par
   58         int vetor1[] = \{1, 1, 1\};\par
   59         REQUIRE(ValidaI_X_C(vetor1, 3) == 0);\par
   60         int vetor2[] = \{10, 10, 10, 10\};\par
   61         REQUIRE(ValidaI_X_C(vetor2, 4) == ERRO);\par
   62         int vetor3[] = \{1, 1, 1, 1\};\par
   63         REQUIRE(ValidaI_X_C(vetor3, 4) == ERRO);\par
   64         int vetor4[] = \{100, 50, 100, 100, 100\};\par
   65         REQUIRE(ValidaI_X_C(vetor4, 5) == 0);\par
   66         int vetor5[] = \{100, 100, 100\};\par
   67         REQUIRE(ValidaI_X_C(vetor5, 3) == 0);\par
   68         int vetor6[] = \{1000, 1000, 500, 100, 100, 100, 10, 100, 1, 10\};\par
   69         REQUIRE(ValidaI_X_C(vetor6, 10) == 0);\par
   70         int vetor7[] = \{100, 1000, 5, 1, 1, 1\};\par
   71         REQUIRE(ValidaI_X_C(vetor7, 6) == 0);\par
   72     \}\par
   73 \par
   74     //essa secao testa a funcao ValidaSubstracoesCombinadas\par
   75     SECTION("Testando a funcao que valida a as subtracoes combinadas")\{\par
   76         int vetor[] = \{1, 9, 10\};\par
   77         REQUIRE(ValidaSubstracoesCombinadas(vetor, 3) == ERRO);\par
   78         int vetor1[] = \{1, 1, 1\};\par
   79         REQUIRE(ValidaSubstracoesCombinadas(vetor1, 3) == 0);\par
   80         int vetor2[] = \{100, 10, 50, 10\};\par
   81         REQUIRE(ValidaSubstracoesCombinadas(vetor2, 4) == ERRO);\par
   82         int vetor3[] = \{100, 1, 50, 100\};\par
   83         REQUIRE(ValidaSubstracoesCombinadas(vetor3, 4) == ERRO);\par
   84         int vetor4[] = \{100, 10, 50, 1, 10\};\par
   85         REQUIRE(ValidaSubstracoesCombinadas(vetor4, 5) == 0);\par
   86         int vetor5[] = \{10, 100, 1, 10\};\par
   87         REQUIRE(ValidaSubstracoesCombinadas(vetor5, 4) == 0);\par
   88         int vetor6[] = \{1, 1, 10\};\par
   89         REQUIRE(ValidaSubstracoesCombinadas(vetor6, 3) == ERRO);\par
   90         int vetor7[] = \{5, 10\};\par
   91         REQUIRE(ValidaSubstracoesCombinadas(vetor7, 2) == ERRO);\par
   92         int vetor8[] = \{1, 10, 10\};\par
   93         REQUIRE(ValidaSubstracoesCombinadas(vetor8, 3) == ERRO);\par
   94         int vetor9[] = \{1000, 1000, 100, 1000, 10, 100, 1, 10\};\par
   95         REQUIRE(ValidaSubstracoesCombinadas(vetor9, 8) == 0);\par
   96         int vetor10[] = \{100, 1000, 5, 1, 1, 1\};\par
   97         REQUIRE(ValidaSubstracoesCombinadas(vetor10, 6) == 0);\par
   98     \}\par
   99 \par
  100     //essa secao testa a funcao ConverteNumeroRomano\par
  101     // ERRO vale -1\par
  102     SECTION("Testando a funcao que retorna a conversao de romano para arabico")\{\par
  103         REQUIRE(ConverteNumeroRomano("I") == 1);\par
  104         REQUIRE(ConverteNumeroRomano("IV") == 4);   \par
  105         REQUIRE(ConverteNumeroRomano("X") == 10);\par
  106         REQUIRE(ConverteNumeroRomano("XIX") == 19);\par
  107         REQUIRE(ConverteNumeroRomano("CXLIX") == 149);\par
  108         REQUIRE(ConverteNumeroRomano("CCCLXXXVIII") == 388);\par
  109         REQUIRE(ConverteNumeroRomano("CDLXXIV") == 474);\par
  110         REQUIRE(ConverteNumeroRomano("CMVIII") == 908);\par
  111         REQUIRE(ConverteNumeroRomano("MCDXXXVIII") == 1438);\par
  112         REQUIRE(ConverteNumeroRomano("MDCCCLVII") == 1857);\par
  113         REQUIRE(ConverteNumeroRomano("MMCCLXVI") == 2266);\par
  114         REQUIRE(ConverteNumeroRomano("MMDCCCXCIX") == 2899);\par
  115         REQUIRE(ConverteNumeroRomano("MMCMXCVIII") == 2998);\par
  116         REQUIRE(ConverteNumeroRomano("MMM") == 3000);\par
  117         REQUIRE(ConverteNumeroRomano("MMvS") == ERRO);\par
  118         REQUIRE(ConverteNumeroRomano("IiV") == ERRO);\par
  119         REQUIRE(ConverteNumeroRomano("DL2") == ERRO);\par
  120         REQUIRE(ConverteNumeroRomano("XXXXI") == ERRO);\par
  121         REQUIRE(ConverteNumeroRomano("MMZMx") == ERRO);\par
  122         REQUIRE(ConverteNumeroRomano("MMMMM") == ERRO);\par
  123         REQUIRE(ConverteNumeroRomano("MDD") == ERRO);\par
  124         REQUIRE(ConverteNumeroRomano("VV") == ERRO);\par
  125         REQUIRE(ConverteNumeroRomano("VXV") == ERRO);\par
  126         REQUIRE(ConverteNumeroRomano("LC") == ERRO);\par
  127         REQUIRE(ConverteNumeroRomano("VXV") == ERRO);\par
  128         REQUIRE(ConverteNumeroRomano("MMMI") == ERRO);\par
  129         \par
  130     \}\par
  131 \}}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Refer\'EAncia ao ficheiro src/teste_num_romanos_main.cpp\par \pard\plain 
{\tc\tcl2 \v src/teste_num_romanos_main.cpp}
{\xe \v src/teste_num_romanos_main.cpp}
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "../include/catch.hpp"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b CATCH_CONFIG_MAIN}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Main do Catch. Evita que tenha que sempre recompilar o header do Catch. }{
}\par
}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documenta\'E7\'E3o das macros\par
\pard\plain 
{\xe \v CATCH_CONFIG_MAIN\:teste_num_romanos_main.cpp}
{\xe \v teste_num_romanos_main.cpp\:CATCH_CONFIG_MAIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define CATCH_CONFIG_MAIN}}
\par
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Main do Catch. Evita que tenha que sempre recompilar o header do Catch. }}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \'CDndice\par 
\pard\plain 
{\tc \v \'CDndice}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}